<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Cross-Stitch Generator{% endblock %}</title>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">

    <!-- Tailwind CSS + DaisyUI -->
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.7.2/dist/full.min.css" rel="stylesheet" type="text/css" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                },
            },
            daisyui: {
                themes: ["light"],
            },
        }
    </script>

    <!-- HTMX -->
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>

    <!-- Alpine.js -->
    <script defer src="https://unpkg.com/alpinejs@3.13.5/dist/cdn.min.js"></script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@0.312.0/dist/umd/lucide.min.js"></script>

    <!-- Custom Styles -->
    <style>
        /* Systematic Spacing Variables */
        :root {
            --spacing-1: 4px;   /* Micro spacing (icon-to-text) */
            --spacing-2: 8px;   /* Tight spacing (label-to-control) */
            --spacing-3: 16px;  /* Standard spacing (within sections) */
            --spacing-4: 24px;  /* Section spacing (between control groups) */
            --spacing-5: 32px;  /* Major spacing (sidebar padding) */
        }

        body { font-family: 'Inter', sans-serif; }

        /* Aida cloth grid pattern */
        .canvas-grid {
            background-image: radial-gradient(#e2e8f0 1px, transparent 1px);
            background-size: 20px 20px;
        }

        /* Modern Atelier data labels */
        .label-data {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.025em;
            font-weight: 500;
            color: #64748b;
        }

        /* Custom range slider styling for Modern Atelier */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #475569;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: background-color 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #334155;
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #475569;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: background-color 0.2s ease;
        }

        input[type="range"]::-moz-range-thumb:hover {
            background: #334155;
        }

        /* HTMX loading indicator */
        .htmx-indicator {
            opacity: 0;
            transition: opacity 200ms ease-in;
        }
        .htmx-request .htmx-indicator {
            opacity: 1;
        }
        .htmx-request.htmx-indicator {
            opacity: 1;
        }

        /* Magic Moment Reveal (Darkroom Effect) */
        .magic-moment {
            animation: magicReveal var(--magic-duration, 1.2s) ease-out;
        }
        @keyframes magicReveal {
            0% {
                opacity: 0;
                transform: scale(0.95);
                filter: blur(8px);
            }
            60% {
                opacity: 0.7;
                filter: blur(2px);
            }
            100% {
                opacity: 1;
                transform: scale(1);
                filter: blur(0px);
            }
        }

        /* Button success state animation */
        .success-flash {
            animation: successFlash 0.8s ease-out;
        }
        @keyframes successFlash {
            0% { background-color: rgb(16 185 129); }
            50% { background-color: rgb(5 150 105); transform: scale(1.02); }
            100% { background-color: rgb(16 185 129); transform: scale(1); }
        }

        /* Modern form focus states */
        input:focus, button:focus {
            outline: 2px solid #94a3b8;
            outline-offset: 2px;
        }

        /* Enhanced radio and checkbox styling */
        input[type="radio"]:checked, input[type="checkbox"]:checked {
            background-color: #475569;
            border-color: #475569;
        }
    </style>

    {% block head %}{% endblock %}
</head>
<body class="h-full bg-white font-sans antialiased" x-data="appState()">
    {% block body %}{% endblock %}

    <script>
        // Initialize Lucide icons
        lucide.createIcons();

        // Alpine.js application state
        function appState() {
            return {
                // UI State
                sidebarOpen: true,
                viewMode: 'stitch', // 'stitch' | 'map' (segmented control)
                showLegend: false,
                zoom: 1,

                // Configuration State (maps 1:1 to PatternConfig Pydantic model)
                config: {
                    resolution: 100,
                    max_colors: 64,
                    quantization: 'median_cut',
                    edge_mode: 'smooth',
                    transparency: 'white_background',
                    min_color_percent: 1.0,
                    enable_dmc: true,
                    dmc_only: false,
                },

                // Application State
                jobId: null,
                hasImage: false,
                isGenerating: false,
                processingStatus: 'idle', // 'idle' | 'uploading' | 'generating' | 'complete' | 'error'
                patternData: null,

                // Panel State
                essentialsOpen: true,
                advancedOpen: false,
                customDmcFile: null,
                showSubtitles: false, // Hide subtitles by default for cleaner look

                // Display Effects State
                effects: {
                    preset: 'default',
                    magicMomentEnabled: true,
                    canvasAnimationsEnabled: true,
                    reducedMotion: false
                },

                // Methods
                toggleSidebar() {
                    this.sidebarOpen = !this.sidebarOpen;
                },

                setViewMode(mode) {
                    this.viewMode = mode;
                    if (this.patternData) {
                        this.$dispatch('render-pattern', { mode });
                    }
                },

                // Enhanced methods for effect management
                setEffectPreset(preset) {
                    if (typeof DisplayEffectsManager !== 'undefined') {
                        DisplayEffectsManager.loadPreset(preset);
                        this.effects.preset = preset;

                        // Update individual toggles to reflect preset settings
                        this.effects.magicMomentEnabled = DisplayEffectsManager.config.magicMoment.enabled;
                        this.effects.canvasAnimationsEnabled = DisplayEffectsManager.config.canvas.resizeAnimation.enabled;

                        localStorage.setItem('effectPreset', preset);
                        console.log(`üé® Effect preset changed to: ${preset}`);
                    } else {
                        console.warn('‚ö†Ô∏è DisplayEffectsManager not available');
                    }
                },

                toggleMagicMoment() {
                    this.effects.magicMomentEnabled = !this.effects.magicMomentEnabled;
                    if (typeof DisplayEffectsManager !== 'undefined') {
                        DisplayEffectsManager.updateConfig('magicMoment.enabled', this.effects.magicMomentEnabled);
                    }
                    localStorage.setItem('magicMomentEnabled', this.effects.magicMomentEnabled);
                },

                toggleCanvasAnimations() {
                    this.effects.canvasAnimationsEnabled = !this.effects.canvasAnimationsEnabled;
                    if (typeof DisplayEffectsManager !== 'undefined') {
                        DisplayEffectsManager.updateConfig('canvas.resizeAnimation.enabled', this.effects.canvasAnimationsEnabled);
                        DisplayEffectsManager.updateConfig('canvas.smoothTransitions', this.effects.canvasAnimationsEnabled);
                    }
                    localStorage.setItem('canvasAnimationsEnabled', this.effects.canvasAnimationsEnabled);
                },

                // Check if symbols are available (cells large enough to render symbols)
                symbolsAvailable() {
                    if (!this.patternData) return false;

                    // Calculate the same cell size as PatternStore
                    const maxCanvasSize = Math.min(window.innerWidth - 400, window.innerHeight - 100);
                    const maxDimension = Math.max(this.patternData.width, this.patternData.height);
                    const cellSize = Math.max(2, Math.floor(maxCanvasSize / maxDimension));

                    return cellSize >= 8; // Same threshold as pattern-store.js
                },

                symbolsTooltipText() {
                    if (!this.patternData) return '';

                    if (this.symbolsAvailable()) {
                        return 'Show pattern with symbols for color identification';
                    } else {
                        const maxDimension = Math.max(this.patternData.width, this.patternData.height);
                        return `Symbols not available for ${maxDimension}√ó${maxDimension} patterns. Try a smaller resolution (‚â§120√ó120) to enable symbols.`;
                    }
                },

                zoomIn() {
                    this.zoom = Math.min(this.zoom * 1.25, 5);
                },

                zoomOut() {
                    this.zoom = Math.max(this.zoom / 1.25, 0.25);
                },

                resetZoom() {
                    this.zoom = 1;
                },

                toggleAdvanced() {
                    this.advancedOpen = !this.advancedOpen;
                    localStorage.setItem('advancedOpen', this.advancedOpen);
                },

                toggleEssentials() {
                    this.essentialsOpen = !this.essentialsOpen;
                    localStorage.setItem('essentialsOpen', this.essentialsOpen);
                },

                toggleSubtitles() {
                    this.showSubtitles = !this.showSubtitles;
                    localStorage.setItem('showSubtitles', this.showSubtitles);
                },

                // Clean config to only include fields expected by PatternConfig model
                getCleanConfig() {
                    const cleanConfig = {
                        resolution: this.config.resolution,
                        max_colors: this.config.max_colors,
                        quantization: this.config.quantization,
                        edge_mode: this.config.edge_mode,
                        transparency: this.config.transparency,
                        min_color_percent: this.config.min_color_percent,
                        enable_dmc: this.config.enable_dmc,
                        dmc_only: this.config.dmc_only
                    };

                    console.log('üßπ [FRONTEND] Cleaned config (removed extra fields):', cleanConfig);
                    return cleanConfig;
                },

                async regeneratePattern() {
                    if (!this.jobId) {
                        showNotification('Please upload an image first', 'error');
                        return;
                    }

                    this.isGenerating = true;
                    this.processingStatus = 'Regenerating pattern...';

                    try {
                        // Enhanced logging for config debugging
                        console.log('üé® [FRONTEND] Starting pattern regeneration');
                        console.log('üìã [FRONTEND] Job ID:', this.jobId);
                        console.log('‚öôÔ∏è [FRONTEND] Raw config object (with extra fields):', this.config);

                        // Get clean config (only fields expected by PatternConfig model)
                        const cleanConfig = this.getCleanConfig();
                        console.log('üìê [FRONTEND] Clean config details:');
                        console.log('   Resolution:', cleanConfig.resolution, '(type:', typeof cleanConfig.resolution, ')');
                        console.log('   Max Colors:', cleanConfig.max_colors, '(type:', typeof cleanConfig.max_colors, ')');
                        console.log('   Quantization:', cleanConfig.quantization, '(type:', typeof cleanConfig.quantization, ')');
                        console.log('   Edge Mode:', cleanConfig.edge_mode, '(type:', typeof cleanConfig.edge_mode, ')');
                        console.log('   Transparency:', cleanConfig.transparency, '(type:', typeof cleanConfig.transparency, ')');
                        console.log('   Min Color %:', cleanConfig.min_color_percent, '(type:', typeof cleanConfig.min_color_percent, ')');
                        console.log('   Enable DMC:', cleanConfig.enable_dmc, '(type:', typeof cleanConfig.enable_dmc, ')');
                        console.log('   DMC Only:', cleanConfig.dmc_only, '(type:', typeof cleanConfig.dmc_only, ')');

                        const configJson = JSON.stringify(cleanConfig);
                        console.log('üì§ [FRONTEND] Stringified clean config:', configJson);
                        console.log('üìè [FRONTEND] Config JSON length:', configJson.length);

                        const response = await fetch(`/api/generate/${this.jobId}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: configJson
                        });

                        console.log('üì° [FRONTEND] Response status:', response.status, response.statusText);
                        console.log('üì° [FRONTEND] Response headers:', Object.fromEntries(response.headers.entries()));

                        if (!response.ok) {
                            const errorText = await response.text();
                            console.error('‚ùå [FRONTEND] Error response body:', errorText);

                            let errorMessage = 'Generation failed';
                            try {
                                const error = JSON.parse(errorText);
                                errorMessage = error.detail || error.message || 'Generation failed';
                            } catch (parseError) {
                                console.error('‚ùå [FRONTEND] Failed to parse error response as JSON:', parseError);
                                errorMessage = errorText || 'Generation failed';
                            }

                            throw new Error(errorMessage);
                        }

                        const responseText = await response.text();
                        console.log('‚úÖ [FRONTEND] Success response body (first 200 chars):', responseText.substring(0, 200));

                        const patternData = JSON.parse(responseText);
                        console.log('‚úÖ [FRONTEND] Parsed pattern data:', {
                            width: patternData.width,
                            height: patternData.height,
                            palette_length: patternData.palette?.length,
                            grid_length: patternData.grid?.length,
                            threads_length: patternData.threads?.length
                        });

                        this.patternData = patternData;
                        this.isGenerating = false;
                        this.processingStatus = 'complete';

                        // Reset to normal after 1.5 seconds
                        setTimeout(() => {
                            this.processingStatus = 'idle';
                        }, 1500);

                        // Trigger magic moment reveal (this is regeneration, not initial load)
                        this.$dispatch('magic-moment', {
                            data: patternData,
                            isInitialLoad: false,  // This is regeneration, not first load
                            effectConfig: typeof DisplayEffectsManager !== 'undefined' ? DisplayEffectsManager.config : null
                        });

                        // Preserve current view mode (symbols/colors) after regeneration
                        this.$dispatch('render-pattern', { mode: this.viewMode });

                    } catch (error) {
                        this.isGenerating = false;
                        this.processingStatus = 'error';
                        console.error('‚ùå [FRONTEND] Pattern generation failed:', error);
                        showNotification(error.message, 'error');
                    }
                },

                init() {
                    const savedAdvanced = localStorage.getItem('advancedOpen');
                    this.advancedOpen = savedAdvanced === 'true';

                    const savedEssentials = localStorage.getItem('essentialsOpen');
                    this.essentialsOpen = savedEssentials !== 'false'; // Default to true

                    const savedSubtitles = localStorage.getItem('showSubtitles');
                    this.showSubtitles = savedSubtitles === 'true'; // Default to false for cleaner look

                    // Load effect preferences
                    const savedMagicMoment = localStorage.getItem('magicMomentEnabled');
                    this.effects.magicMomentEnabled = savedMagicMoment !== 'false'; // Default to true

                    const savedCanvasAnimations = localStorage.getItem('canvasAnimationsEnabled');
                    this.effects.canvasAnimationsEnabled = savedCanvasAnimations !== 'false'; // Default to true

                    const savedPreset = localStorage.getItem('effectPreset');
                    if (savedPreset && typeof DisplayEffectsManager !== 'undefined') {
                        this.setEffectPreset(savedPreset);
                    } else if (typeof DisplayEffectsManager !== 'undefined') {
                        // Apply individual settings to DisplayEffectsManager
                        DisplayEffectsManager.updateConfig('magicMoment.enabled', this.effects.magicMomentEnabled);
                        DisplayEffectsManager.updateConfig('canvas.resizeAnimation.enabled', this.effects.canvasAnimationsEnabled);
                        DisplayEffectsManager.updateConfig('canvas.smoothTransitions', this.effects.canvasAnimationsEnabled);
                    }

                    console.log('‚ú® Alpine.js app state initialized with effects:', this.effects);
                },
            };
        }
    </script>

    <!-- Pattern Store and Interactions -->
    <script src="/static/js/display-effects.js"></script>
    <script src="/static/js/pattern-store.js"></script>
    <script src="/static/js/upload-handler.js"></script>
    <script src="/static/js/interactions.js"></script>

    {% block scripts %}{% endblock %}
</body>
</html>